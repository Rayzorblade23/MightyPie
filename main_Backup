import json
import math
import os
import time
import threading
import tkinter as tk
import win32con
import win32gui
import win32process
import win32api
import psutil
import ctypes
import keyboard
from config import CONFIG

# Cache Management
CACHE_FILE = os.path.join(
    os.path.dirname(os.path.abspath(__file__)), "app_name_cache.json"
)


def load_cache():
    """Load application name cache from file."""
    if os.path.exists(CACHE_FILE):
        try:
            with open(CACHE_FILE, "r") as f:
                return json.load(f)
        except Exception as e:
            print(f"Error loading cache file: {e}")
            return {}
    return {}


def save_cache(cache):
    """Save application name cache to file."""
    try:
        with open(CACHE_FILE, "w") as f:
            json.dump(cache, f, indent=4)
        print("Cache saved successfully.")
    except Exception as e:
        print(f"Error saving cache file: {e}")


# Window and Process Information Retrieval
def get_pid_from_window_handle(hwnd):
    """Retrieve the Process ID (PID) for a given window handle."""
    try:
        _, pid = win32process.GetWindowThreadProcessId(hwnd)
        return pid
    except Exception as e:
        print(f"Error retrieving PID for window: {e}")
        return None


def get_file_description(exe_path):
    """Get the FileDescription (friendly app name) from the executable."""
    try:
        language, codepage = win32api.GetFileVersionInfo(
            exe_path, "\\VarFileInfo\\Translation"
        )[0]
        string_file_info = "\\StringFileInfo\\%04X%04X\\%s" % (
            language,
            codepage,
            "FileDescription",
        )
        description = win32api.GetFileVersionInfo(exe_path, string_file_info)
        return description if description else "Unknown App"
    except Exception as e:
        print(f"Error retrieving file description for {exe_path}: {e}")
        return "Unknown App"


def get_application_name(window_title):
    """Retrieve the application name for a given window title."""
    try:
        window_handle = window_handles.get(window_title)
        if window_handle:
            pid = get_pid_from_window_handle(window_handle)
            if pid:
                process = psutil.Process(pid)
                exe_path = process.exe()
                if os.path.exists(exe_path):
                    exe_name = os.path.basename(exe_path).lower()
                    if exe_name in app_cache:
                        app_name = app_cache[exe_name]
                    else:
                        app_name = get_file_description(exe_path)
                        app_cache[exe_name] = app_name
                        save_cache(app_cache)
                    return app_name
        return "Unknown App"
    except Exception as e:
        print(f"Error fetching application name for {window_title}: {e}")
        return "Unknown App"


# Window Enumeration and Handling
def get_window_list():
    """Enumerate and retrieve a list of visible windows."""
    local_window_handles = {}
    program_window_handle = win32gui.GetParent(window.winfo_id())
    print(program_window_handle)

    def enum_windows_callback(hwnd, lparam):
        if win32gui.IsWindowVisible(hwnd):
            window_title = win32gui.GetWindowText(hwnd)
            class_name = win32gui.GetClassName(hwnd)

            isCloaked = ctypes.c_int(0)
            ctypes.WinDLL("dwmapi").DwmGetWindowAttribute(
                hwnd, 14, ctypes.byref(isCloaked), ctypes.sizeof(isCloaked)
            )

            if (
                win32gui.IsWindowVisible(hwnd)
                and isCloaked.value == 0
                and window_title.strip()
                and class_name != "Progman"
            ):
                if hwnd != program_window_handle:
                    local_window_handles[window_title] = hwnd

    try:
        win32gui.EnumWindows(enum_windows_callback, None)
        window_handles.clear()
        window_handles.update(local_window_handles)
        return list(window_handles.keys())
    except Exception as e:
        print(f"Error getting windows: {e}")
        return []


def focus_window_by_handle(hwnd):
    """Bring a window to the foreground and restore/maximize as needed."""
    try:
        win32gui.SetForegroundWindow(hwnd)
        placement = win32gui.GetWindowPlacement(hwnd)

        if placement[1] == win32con.SW_MINIMIZE:
            win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
        elif placement[1] == win32con.SW_SHOWMAXIMIZED:
            pass
        else:
            win32gui.ShowWindow(hwnd, win32con.SW_SHOWNORMAL)

        win32gui.SetForegroundWindow(hwnd)
    except Exception as e:
        print(f"Could not focus window with handle '{hwnd}': {e}")


# Window Management Functions
def show_window():
    """Display the main window and bring it to the foreground."""
    try:
        if not window.winfo_viewable():
            window.deiconify()

        hwnd = win32gui.GetParent(window.winfo_id())
        print(hwnd)
        win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)

        fg_window = win32gui.GetForegroundWindow()
        fg_thread, _ = win32process.GetWindowThreadProcessId(fg_window)
        this_thread = win32api.GetCurrentThreadId()

        if fg_thread != this_thread:
            ctypes.windll.user32.AttachThreadInput(this_thread, fg_thread, True)

        try:
            win32gui.SetForegroundWindow(hwnd)
        except Exception as e:
            print(f"Error setting foreground window: {e}")
            ctypes.windll.user32.BringWindowToTop(hwnd)

        if fg_thread != this_thread:
            ctypes.windll.user32.AttachThreadInput(this_thread, fg_thread, False)

        ctypes.windll.user32.SetWindowPos(
            hwnd,
            win32con.HWND_TOPMOST,
            0,
            0,
            0,
            0,
            win32con.SWP_NOMOVE | win32con.SWP_NOSIZE,
        )
        ctypes.windll.user32.SetWindowPos(
            hwnd,
            win32con.HWND_NOTOPMOST,
            0,
            0,
            0,
            0,
            win32con.SWP_NOMOVE | win32con.SWP_NOSIZE,
        )
    except Exception as e:
        print(f"Error showing the main window: {e}")


def on_close():
    """Handle window close event by hiding the window."""
    window.withdraw()


# Hotkey and Refresh Management
def listen_for_hotkeys():
    """Listen for global hotkeys."""
    keyboard.add_hotkey(CONFIG.HOTKEY_OPEN, show_window, suppress=True)
    keyboard.wait()


def refresh():
    """Trigger a manual refresh of window buttons."""
    update_buttons()


def auto_refresh():
    """Automatically monitor and refresh windows periodically."""

    def monitor_windows():
        global last_window_list

        def check_windows():
            global last_window_list
            current_window_list = get_window_list()
            if current_window_list != last_window_list:
                last_window_list = current_window_list
                refresh()
            window.after(CONFIG.REFRESH_INTERVAL, check_windows)

        window.after(0, check_windows)

    threading.Thread(target=monitor_windows, daemon=True).start()


# Button Management
def update_buttons():
    """Update window buttons with current window information."""
    global button_window_mapping, button_text_mapping

    def background_task():
        windows = get_window_list()
        current_window_mapping = {}
        current_button_text_mapping = {}

        for i, window_title in enumerate(windows):
            window_handle = window_handles.get(window_title)
            if not window_handle:
                continue

            app_name = get_application_name(window_title)
            button_title = (
                window_title
                if f" - {app_name}" not in window_title
                else window_title.replace(f" - {app_name}", "")
            )
            button_text = f"{button_title}\n{app_name}"

            if window_handle in button_window_mapping:
                button_index = button_window_mapping[window_handle]
            else:
                button_index = None
                for j in range(CONFIG.MAX_BUTTONS):
                    if button_names[j].get() == "Empty":
                        button_index = j
                        break

                if button_index is None:
                    continue

                button_window_mapping[window_handle] = button_index

            button_names[button_index].set(button_text)
            buttons[button_index].config(
                command=lambda hwnd=window_handle: (
                    focus_window_by_handle(hwnd),
                    window.withdraw(),
                )
            )

            current_window_mapping[window_handle] = button_index
            current_button_text_mapping[window_handle] = button_text

        for i in range(CONFIG.MAX_BUTTONS):
            if i not in current_window_mapping.values():
                button_names[i].set("Empty")
                buttons[i].config(command=lambda: None)

        with lock:
            button_window_mapping.update(current_window_mapping)
            button_text_mapping.update(current_button_text_mapping)

        window.after(0, lambda: None)

    threading.Thread(target=background_task, daemon=True).start()


# Global Variables and Initialization
last_window_list = []
window_handles = {}
button_window_mapping = {}
button_text_mapping = {}
lock = threading.Lock()
app_cache = load_cache()


# Tkinter Window Setup
window = tk.Tk()
window.title("Pie Task Switcher")
window.configure(bg="#f0f0ff")

window.withdraw()  # don't draw window on start

# Button Configuration
button_names = [tk.StringVar(value="Empty") for _ in range(CONFIG.MAX_BUTTONS)]
buttons = []

canvas = tk.Canvas(
    window, width=500, height=500, bg="#050505", bd=0, highlightthickness=0
)
canvas.grid(row=0, column=0, padx=20, pady=20)


# Circle center and radius
center_x, center_y = 250, 250  # Center of the canvas
radius = 150  # Radius of the circle for the buttons


def create_circle(x, y, r, canvas):  # center coordinates, radius
    x0 = x - r
    y0 = y - r
    x1 = x + r
    y1 = y + r
    return canvas.create_oval(x0, y0, x1, y1, fill="green")


create_circle(center_x, center_y, radius, canvas)

pixel = tk.PhotoImage(
    width=1, height=1
)  # create an image to make buttons use pixel size

# Starting angle
angle_in_degrees = 0  # Start at 0 degrees
angle_in_radians = math.radians(angle_in_degrees)  # Convert to radians

# Create 8 buttons in a circular pattern
for i, name in enumerate(button_names):
    angle_in_degrees = i / 8 * 360
    # Calculate button's position using angle_in_radians

    offset_x = 0
    offset_y = 0

    if i == 0:
        offset_x += 0
        offset_y += 0
    elif i == 1:
        offset_x += CONFIG.BUTTON_WIDTH / 2 - CONFIG.BUTTON_HEIGHT / 2
        offset_y += -CONFIG.BUTTON_HEIGHT / 2
    elif i == 2:
        offset_x += CONFIG.BUTTON_WIDTH / 2 - CONFIG.BUTTON_HEIGHT / 2
        offset_y += 0
    elif i == 3:
        offset_x += CONFIG.BUTTON_WIDTH / 2 - CONFIG.BUTTON_HEIGHT / 2
        offset_y += CONFIG.BUTTON_HEIGHT / 2
    elif i == 4:
        offset_x += 0
        offset_y += 0
    elif i == 5:
        offset_x += -(CONFIG.BUTTON_WIDTH / 2 - CONFIG.BUTTON_HEIGHT / 2)
        offset_y += CONFIG.BUTTON_HEIGHT / 2
    elif i == 6:
        offset_x += -(CONFIG.BUTTON_WIDTH / 2 - CONFIG.BUTTON_HEIGHT / 2)
        offset_y += 0
    elif i == 7:
        offset_x += -(CONFIG.BUTTON_WIDTH / 2 - CONFIG.BUTTON_HEIGHT / 2)
        offset_y += -CONFIG.BUTTON_HEIGHT / 2

    button_x = center_x + offset_x + radius * math.sin(math.radians(angle_in_degrees))
    button_y = center_y - offset_y - radius * math.cos(math.radians(angle_in_degrees))

    # Output the button name and its calculated positio+
    print(f"{name} position: ({button_x:.2f}, {button_y:.2f})")
    print(f"x = {button_x:.4f}, y = {button_y:.4f}, angle = {angle_in_degrees:.2f}°")

    # Create button at calculated position
    btn = tk.Button(
        window,
        textvariable=name,
        image=pixel,
        width=CONFIG.BUTTON_WIDTH,
        height=CONFIG.BUTTON_HEIGHT,
        compound="c",
    )
    buttons.append(btn)

    # Place the button on the canvas
    canvas.create_window(button_x, button_y, window=btn)


# Create the center refresh button
refresh_btn = tk.Button(
    window,
    text="R",
    command=refresh,
    image=pixel,
    width=CONFIG.BUTTON_HEIGHT,
    height=CONFIG.BUTTON_HEIGHT,
    compound="c",
)

canvas.create_window(center_x, center_y, window=refresh_btn)

# Window Size Configuration
window.update_idletasks()
window_width = canvas.winfo_width() + 40
window_height = canvas.winfo_height() + 60
window.geometry(f"{window_width}x{window_height}")


# Window Protocol
window.protocol("WM_DELETE_WINDOW", on_close)

# Hotkey Thread
hotkey_thread = threading.Thread(target=listen_for_hotkeys, daemon=True)
hotkey_thread.start()

# Initial Refresh and Auto-refresh
refresh()
auto_refresh()

# Start the GUI Event Loop
if __name__ == "__main__":
    window.mainloop()
